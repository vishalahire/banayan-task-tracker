# üß≠ 1. Overall Development Approach

## **1.1 Objectives**

Design and build a modern full-stack **Task Tracker** with:

### **Backend**
- .NET 8 Web API  
- EF Core  
- PostgreSQL  

### **Frontend**
- React  
- Vite  
- TypeScript  
- Tailwind CSS  

### **Authentication**
- JWT with ASP.NET Identity  

### **Infrastructure**
- Docker Compose  

### **Architecture**
Clean Architecture:


### **Required Features**
- Secure login  
- Task CRUD  
- File attachments  
- Search & filtering  
- Reminders (demo-triggered)  
- Audit trail  
- Rate limiting  
- Observability/logging  
- Health checks  
- Tests (unit + integration)  
- Documentation  

The solution must be **clean, maintainable, testable**, and show **thoughtful engineering decisions**.

---

## **1.2 Development Strategy**

The development followed a **hybrid AI-assisted architecture-driven workflow**:

---

### ‚≠ê **ChatGPT was the Architect**
- Broke down requirements  
- Designed architecture  
- Created structured prompts for Copilot  
- Guided decisions on database, authentication, Docker, reminders  
- Helped debug tricky issues (Identity setup, migrations, worker logic)  
- Generated documentation and rationales  

---

### ‚≠ê **GitHub Copilot was the Engineer**
- Generated scaffolding  
- Implemented services, controllers, and infrastructure  
- Built React components & routing  
- Created Dockerfiles & docker-compose stack  
- Produced repetitive boilerplate code  
- Generated tests  
- Drafted markdown documentation  

---

This split allowed:

| ChatGPT | Copilot |
|---------|----------|
| High-level reasoning | Code generation with guardrails |
| Architecture design | Implementation |
| Prompt engineering | Automated development |
| Documentation | Scaffolding |

---

## **1.3 Technical Architecture**

A **clean architecture** pattern was chosen:


This ensures:

- **Testability**  
- **Decoupling**  
- **Layered responsibilities**  
- **Flexibility** for scaling or future production constraints  

---

## **1.4 Execution Roadmap**

The development followed **11 structured steps**, each driven by a dedicated Copilot prompt:

1. Environment setup (VS Code, Docker, Copilot, extensions)  
2. High-level backend structure  
3. Domain + Application + Infrastructure + EF Core  
4. Controllers + Authentication  
5. Middleware + Observability + Rate limiting  
6. Initial worker-based reminders  
7. Full frontend implementation  
8. Containerization (Dockerfiles + Docker Compose)  
9. Revised reminder logic via API endpoint and UI  
10. Minimal backend + frontend tests  
11. Documentation + design artifacts  

Each step came with a dedicated prompt carefully engineered via ChatGPT.

---

# üß† 2. AI-Assisted Workflow Summary

## ‚úîÔ∏è **Why AI Was Used**
- Large assignment scope  
- Need for consistent structure  
- Clean architecture expectations  
- Reduce repetitive coding  
- Keep focus on design over syntax  

---

## ‚úîÔ∏è **How ChatGPT Helped**
- Designed all the prompts  
- Sequenced implementation steps  
- Ensured architectural consistency  
- Identified and explained trade-offs  
- Debugged Identity issues and EF migrations  
- Drafted documentation & rationale  

---

## ‚úîÔ∏è **How Copilot Helped**
- Implemented backend & frontend code  
- Generated the bulk of boilerplate  
- Produced routes, controllers, services  
- Created Dockerfiles and compose stack  
- Built initial test scaffolds  
- Maintained consistency when following structured prompts  

---

# üì¶ 3. Full Prompt Log (All Prompts in Chronological Order)

The following represents the **actual intent prompts** used during development.  
Each of these was generated by ChatGPT and pasted into GitHub Copilot during implementation.

---

## **3.1 High-Level System Prompt**

You are helping me build a full-stack Task Tracker application using:

Backend: .NET 8 Web API, EF Core, PostgreSQL

Frontend: React with Vite + TypeScript

Infrastructure: Docker Compose

Auth: JWT with ASP.NET Identity

Architecture: Domain ‚Üí Application ‚Üí Infrastructure ‚Üí API

Features: tasks, attachments, search, filtering, reminders, audit logs, rate limiting, observability

Do NOT generate code yet.
Acknowledge and wait for the next prompts.


---

## **3.2 Backend Project Structure Prompt**

Generate a clean backend project structure with:

src/
TaskTracker.Domain
TaskTracker.Application
TaskTracker.Infrastructure
TaskTracker.Api

Create projects + references only.
Do not generate logic yet.


---

## **3.3 Domain Models + Infrastructure Prompt**

Now create Domain entities and Infrastructure layer:

Entities:

Task

Attachment

ReminderLog

AuditEvent

User (Identity-based)

Add:

TaskTrackerDbContext

EF Core configurations

Repositories for task, attachment, reminder, audit

Application service interfaces

Reuse existing code where possible.
Extend, don‚Äôt recreate.


---

## **3.4 Controllers + Authentication Prompt**

Generate controllers for:

Auth (JWT login/register)

Tasks

Attachments

Audit

Filtering/search

Requirements:

Use dependency injection

Apply authorization (users can modify only their own tasks)

Consistent error responses

Use Application layer services


---

## **3.5 Middleware + API Infrastructure Prompt**

Add API infrastructure:

Exception handling middleware

Correlation ID middleware

Rate limiting per user/IP

Logging (structured)

CORS for React

Swagger/OpenAPI

Health checks

Update Program.cs accordingly.
Install required NuGet packages.


---

## **3.6 Worker Service (Initial Reminder Logic)**

Implement a background worker:

ReminderWorker : BackgroundService

Inject IReminderService

Run every 5 minutes

Log reminders idempotently

Add Dockerfile.worker

Add worker service to docker-compose


---

## **3.7 Frontend Prompt (React + Vite + TS + Tailwind)**

Implement the frontend using React + Vite + TypeScript + Tailwind CSS.

Create folder structure:

routes/

components/

api/

hooks/

types/

Implement pages:

LoginPage

TaskListPage

TaskDetailPage

TaskEditPage

ChangePasswordPage

Attachment management

Add:

API client wrapper

Auth hook/context

Tailwind configuration

Environment variable for API base URL


---

## **3.8 Docker Containerization Prompt**


Containerize the entire system.

Create:

infra/Dockerfile.api

infra/Dockerfile.worker

infra/Dockerfile.web

Create docker-compose.yml with:

Postgres

API

Worker

Web

Use environment variables:

TASKTRACKER_CONNECTION_STRING

ASPNETCORE_ENVIRONMENT

VITE_API_BASE_URL

Modify Program.cs to read DB connection string from env first.


---

## **3.9 Reminder Endpoint + UI Prompt (Final Reminder Solution)**

Add a manual reminder triggering mechanism.

Backend:

GET /api/reminders/pending

POST /api/reminders/process

Use PendingReminderDto

Reuse IReminderService

No SMTP, just mark reminders logged

Frontend:

Add RemindersPage

Display pending reminders

‚ÄúSend reminders‚Äù button triggers POST

Update UI accordingly


---

## **3.10 Testing Prompt (Minimal Tests)**

Create minimal tests.

Backend Unit Tests:

Domain: test simple entity logic

Application: test simple service logic

Integration Tests:

Use WebApplicationFactory

Test:

Health endpoint

Login ‚Üí Create ‚Üí Fetch ‚Üí Delete task

Frontend:

Setup Vitest + React Testing Library

Test LoginPage renders input fields

Test TaskListPage renders mocked tasks

Keep tests small


---

## **3.11 Documentation Prompt**

Now finalize documentation.

README.md:

Overview

Tech stack

Quickstart (docker compose)

URLs (API, Swagger, frontend)

Link to architecture-and-design folder

DEVELOPER.md:

Tools with download links

Setup instructions

Docker instructions

Health checks

Logs

Running tests

AI usage summary

Architecture folder includes:

approach.md (this file)

prompts-used.md

architecture-diagram.md

design-decisions.md

Reuse any existing markdown files.
Produce updated versions.


---

# ‚úÖ End of Document

This file now contains:

- The entire development approach  
- The AI-assisted workflow  
- The full prompt history  
- Clean Markdown structuring  

You can paste this directly into your repository as-is.
