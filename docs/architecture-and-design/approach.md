üß≠ 1. Overall Development Approach
1.1 Objectives

Design and build a modern full-stack Task Tracker with:

Backend: .NET 8 Web API, EF Core, PostgreSQL

Frontend: React, Vite, TypeScript, Tailwind

Auth: JWT with ASP.NET Identity

Infra: Docker Compose

Architecture: Clean Architecture ‚Üí Domain ‚Üí Application ‚Üí Infrastructure ‚Üí API

Features:

Secure login

Task CRUD

File attachments

Search & filtering

Reminders (demo-triggered)

Audit trail

Rate limiting

Observability/logging

Health checks

Tests (unit + integration)

Documentation

The solution must be clean, maintainable, testable, and show thoughtful engineering decisions.

1.2 Development Strategy

The development followed a hybrid AI-assisted architecture-driven workflow:

‚≠ê ChatGPT was the Architect

Broke down requirements

Designed architecture

Created structured prompts for Copilot

Guided decisions on database, auth, Docker, reminders

Helped debug tricky issues (Identity, migrations, worker logic)

Generated documentation and rationales

‚≠ê GitHub Copilot was the Engineer

Generated scaffolding

Implemented services, controllers, infrastructure

Created React components & routing

Generated Dockerfiles & docker-compose

Helped with repetitive coding patterns

Generated tests based on given prompts

Created markdown documentation drafts

This split allowed:

ChatGPT ‚Üí high-level reasoning
Copilot ‚Üí code generation with guardrails

1.3 Technical Architecture

A clean architecture was chosen:

Domain        ‚Üí Business entities + rules
Application   ‚Üí Service interfaces + DTOs + validation
Infrastructure‚Üí EF Core, PostgreSQL, repositories
API           ‚Üí Controllers, authentication, middleware
Web           ‚Üí React/Vite frontend
Infra         ‚Üí Docker Compose orchestration


This allowed:

Testability

Decoupling

Layered responsibilities

Swapability (e.g., fit future production constraints)

1.4 Execution Roadmap

The development followed 11 well-defined steps:

Environment setup (VS Code, Docker, Copilot, extensions)

High-level backend structure

Domain + Application + Infra + EF Core

Controllers + Auth

Middleware + Observability

Initial worker-based reminders

Full frontend implementation

Containerization (Dockerfiles + Compose)

Revised reminder logic via API endpoint and UI

Minimal backend + frontend tests

Documentation + design artifacts

Each step was delivered using a dedicated Copilot prompt generated by ChatGPT.

üß† 2. AI-Assisted Workflow Summary
‚úîÔ∏è Why AI Was Used

Large assignment scope

Need for productivity and structure

Desire to follow clean architecture

Avoid boilerplate repetition

Maintain focus on architecture over syntax

‚úîÔ∏è How ChatGPT Helped

Designed all prompts

Sequenced the steps

Explained trade-offs

Ensured no deviations

Generated documentation and explanations

‚úîÔ∏è How Copilot Helped

Implemented full backend & frontend

Generated code from the structured prompts

Created Dockerfiles, tests, UI components

Ensured consistency when following instructions

üì¶ 3. Full Prompt Log (All Prompts in Chronological Order)

The following represents the actual intent prompts used during development.
These were created by ChatGPT and pasted into GitHub Copilot throughout the project.

3.1 High-Level System Prompt
You are helping me build a full-stack Task Tracker application using:
- Backend: .NET 8 Web API, EF Core, PostgreSQL
- Frontend: React with Vite + TypeScript
- Infrastructure: Docker Compose
- Auth: JWT with ASP.NET Identity
- Architecture: Domain ‚Üí Application ‚Üí Infrastructure ‚Üí API
- Features: tasks, attachments, search, filtering, reminders, audit logs, rate limiting, observability

Do NOT generate code yet.
Acknowledge and wait for the next prompts.

3.2 Backend Project Structure Prompt
Generate a clean backend project structure with:

src/
  TaskTracker.Domain
  TaskTracker.Application
  TaskTracker.Infrastructure
  TaskTracker.Api

Create projects + references only. 
Do not generate logic yet.

3.3 Domain Models + Infrastructure Prompt
Now create Domain entities and Infrastructure layer:

Entities:
- Task
- Attachment
- ReminderLog
- AuditEvent
- User (Identity-based)

Add:
- TaskTrackerDbContext
- EF Core configurations
- Repositories for task, attachment, reminder, audit
- Application service interfaces

Reuse existing code where possible.
Extend, don‚Äôt recreate.

3.4 Controllers + Authentication Prompt
Generate controllers for:
- Auth (JWT login/register)
- Tasks
- Attachments
- Audit
- Filtering/search

Requirements:
- Use dependency injection
- Apply authorization (users can modify only their own tasks)
- Consistent error responses
- Use Application layer services

3.5 Middleware + API Infrastructure Prompt
Add API infrastructure:
- Exception handling middleware
- Correlation ID middleware
- Rate limiting per user/IP
- Logging (structured)
- CORS for React
- Swagger/OpenAPI
- Health checks

Update Program.cs accordingly.
Install required NuGet packages.

3.6 Worker Service (Initial Reminder Logic)
Implement a background worker:

- ReminderWorker : BackgroundService
- Inject IReminderService
- Run every 5 minutes
- Log reminders idempotently
- Add Dockerfile.worker
- Add worker service to docker-compose

3.7 Frontend Prompt (React + Vite + TS + Tailwind)
Implement the frontend using React + Vite + TypeScript + Tailwind CSS.

Create folder structure:
- routes/
- components/
- api/
- hooks/
- types/

Implement pages:
- LoginPage
- TaskListPage
- TaskDetailPage
- TaskEditPage
- ChangePasswordPage
- Attachment management

Add:
- API client wrapper
- Auth hook/context
- Tailwind configuration
- Environment variable for API base URL

3.8 Docker Containerization Prompt
Containerize the entire system.

Create:
- infra/Dockerfile.api
- infra/Dockerfile.worker
- infra/Dockerfile.web

Create docker-compose.yml with:
- Postgres
- API
- Worker
- Web

Use environment variables:
- TASKTRACKER_CONNECTION_STRING
- ASPNETCORE_ENVIRONMENT
- VITE_API_BASE_URL

Modify Program.cs to read DB connection string from env first.

3.9 Reminder Endpoint + UI Prompt (Final Reminder Solution)
Add a manual reminder triggering mechanism.

Backend:
- GET /api/reminders/pending
- POST /api/reminders/process
- Use PendingReminderDto
- Reuse IReminderService
- No SMTP, just mark reminders logged

Frontend:
- Add RemindersPage
- Display pending reminders
- ‚ÄúSend reminders‚Äù button triggers POST
- Update UI accordingly

3.10 Testing Prompt (Minimal Tests)
Create minimal tests.

Backend Unit Tests:
- Domain: test simple entity logic
- Application: test simple service logic

Integration Tests:
- Use WebApplicationFactory
- Test:
  - Health endpoint
  - Login ‚Üí Create ‚Üí Fetch ‚Üí Delete task

Frontend:
- Setup Vitest + React Testing Library
- Test LoginPage renders input fields
- Test TaskListPage renders mocked tasks

Keep tests small.

3.11 Documentation Prompt
Now finalize documentation.

README.md:
- Overview
- Tech stack
- Quickstart (docker compose)
- URLs (API, Swagger, frontend)
- Link to architecture-and-design folder

DEVELOPER.md:
- Tools with download links
- Setup instructions
- Docker instructions
- Health checks
- Logs
- Running tests
- AI usage summary

Architecture folder includes:
- approach.md (this file)
- prompts-used.md
- architecture-diagram.md
- design-decisions.md

Reuse any existing markdown files.
Produce updated versions.